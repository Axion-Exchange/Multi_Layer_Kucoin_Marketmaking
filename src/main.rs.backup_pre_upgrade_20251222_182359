//! KuCoin Pure Market Maker - INSTITUTIONAL GRADE v0.4
//!
//! Features:
//! - WebSocket order entry via Co-location endpoint
//! - Real-time fill tracking via private WebSocket
//! - REST polling fallback every 5s
//! - Auto-reconnection with exponential backoff
//! - Full position and P&L tracking

mod config;
mod quant;
mod exchange;
mod strategy;
mod error;

use anyhow::Result;
use tracing::{info, warn, error, Level};
use tracing_subscriber::FmtSubscriber;
use tokio::time::{Duration, interval};
use std::sync::Arc;
use tokio::sync::RwLock;

use crate::config::Config;
use crate::exchange::{
    KucoinAuth, KucoinRestClient, KucoinEndpoints,
    OrderRequest, Side, OrderType, TimeInForce,
    KucoinPrivateWs, new_shared_order_manager, OrderSide,
    WsOrderClientV2, WsOrderRequest, WsCancelRequest,
};
use crate::quant::{
    VolatilityTracker, InventoryManager, BinanceWsFeed,
    LqSkewingCalculator, ElasticSizer, FillQualityTracker, FillQualityAction,
    FqFillSide as FillSide, TrendDetector, TrendConfig, TrendState,
};

#[tokio::main]
async fn main() -> Result<()> {
    let subscriber = FmtSubscriber::builder()
        .with_max_level(Level::INFO)
        .finish();
    tracing::subscriber::set_global_default(subscriber)?;

    info!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    info!("â•‘     KuCoin MM - INSTITUTIONAL GRADE v0.4 [WS ORDERS]      â•‘");
    info!("â•‘     Co-location WS â€¢ Real-time fills â€¢ PnL tracking       â•‘");
    info!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    info!("");

    // Load config
    let config = Config::load()?;
    info!("[INIT] {} | Size: ${:.0} | Spread: {:.1}bps | Maker: {:.2}%", 
        config.market.symbol, 
        config.strategy.order_size_quote, 
        config.strategy.base_spread_bps,
        config.quant.pnl.maker_fee * 100.0);

    // Initialize KuCoin auth
    let auth = KucoinAuth::new(
        config.kucoin.api_key.clone(),
        config.kucoin.api_secret.clone(),
        config.kucoin.api_passphrase.clone(),
        config.kucoin.use_passphrase_v2,
    );

    let endpoints = KucoinEndpoints {
        rest_url: config.kucoin.rest_base_url.clone(),
        ws_public_url: config.kucoin.ws_public_url.clone(),
        ws_private_url: config.kucoin.ws_private_url.clone(),
    };

    // Create REST client (for cancels and fallback)
    let rest_client = Arc::new(KucoinRestClient::new(&endpoints, auth.clone())?);
    info!("[INIT] REST client: {}", config.kucoin.rest_base_url);

    // Create WebSocket order client for co-location
    let use_ws_orders = config.kucoin.use_ws_orders.unwrap_or(false);
    let ws_order_url = config.kucoin.ws_order_url.clone()
        .unwrap_or_else(|| "wss://fgtyhceu.kucoin.com/v1/priv".to_string());
    
    let ws_order_client = if use_ws_orders {
        info!("[INIT] WS Order entry ENABLED: {}", ws_order_url);
        let mut client = WsOrderClientV2::new(
            auth.clone(),
            config.kucoin.rest_base_url.clone(),
            ws_order_url,
        );
        
        // Connect to WS order endpoint
        match client.connect().await {
            Ok(_) => {
                info!("[INIT] âœ“ Connected to WS order endpoint");
                Some(Arc::new(RwLock::new(client)))
            }
            Err(e) => {
                warn!("[INIT] WS order connect failed: {} - falling back to REST", e);
                None
            }
        }
    } else {
        info!("[INIT] WS Order entry DISABLED - using REST");
        None
    };

    // Create order manager for tracking fills
    let order_manager = new_shared_order_manager(config.quant.pnl.maker_fee);
    info!("[INIT] Order manager created");

    // Start Binance price feed
    let binance_symbol = config.quant.lead_lag.binance_symbol.clone();
    let binance_feed = BinanceWsFeed::new(binance_symbol.clone(), 10);
    let binance_state = binance_feed.state();
    let _binance_handle = binance_feed.start().await?;
    info!("[INIT] Binance feed: {}", binance_symbol);

    // Start KuCoin private WebSocket for fills
    let kucoin_ws = KucoinPrivateWs::new(
        auth.clone(),
        config.kucoin.rest_base_url.clone(),
        config.kucoin.ws_private_url.clone(),
        order_manager.clone(),
        config.market.symbol.clone(),
    );
    let ws_state = kucoin_ws.state();
    let _kucoin_ws_handle = kucoin_ws.start().await?;
    info!("[INIT] KuCoin private WS: {}", config.kucoin.ws_private_url);

    // Wait for connections
    tokio::time::sleep(Duration::from_secs(3)).await;

    // Initialize quant modules
    let mut vol_tracker = VolatilityTracker::new(config.quant.volatility.lookback_secs);
    let mut inv_mgr = InventoryManager::new(0.5, config.quant.inventory.max_skew_bps);

    // === KRYPTON MODULES ===
    let mut lq_skewing = LqSkewingCalculator::new(config.quant.lq_skewing.clone());
    let elastic_sizer = ElasticSizer::new(config.quant.elastic_sizing.clone());
    let mut fill_tracker = FillQualityTracker::new(config.quant.fill_quality.clone());
    let mut trend_detector = TrendDetector::new(TrendConfig::default());
    
    info!("[KRYPTON] LQ-Skewing: {} | Elastic: {} | Fill-Quality: {}",
        if config.quant.lq_skewing.enabled { "ON" } else { "OFF" },
        if config.quant.elastic_sizing.enabled { "ON" } else { "OFF" },
        if config.quant.fill_quality.enabled { "ON" } else { "OFF" });

    // Tracking for quote management
    let mut active_bid_id: Option<String> = None;
    let mut active_ask_id: Option<String> = None;
    let mut last_bid_price: f64 = 0.0;
    let mut last_ask_price: f64 = 0.0;

    info!("");
    info!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    info!("[LIVE] Starting MM Loop - {} {}", config.market.symbol,
        if ws_order_client.is_some() { "[WS ORDERS]" } else { "[REST ORDERS]" });
    info!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    // Main trading loop
    let mut ticker = interval(Duration::from_millis(config.strategy.refresh_interval_ms));
    let mut poll_ticker = interval(Duration::from_secs(5));
    let mut latency_ticker = interval(Duration::from_secs(30));
    let mut quote_count: u64 = 0;
    // === MOMENTUM-BASED ENTRY ===
    let mut last_signal_direction: i8 = 0;
    let mut signal_start_time = std::time::Instant::now();
    let mut last_fill_time = std::time::Instant::now();
    let mut last_logged_signal: i8 = 0;
    let mut last_poll_fills: u64 = 0;

    loop {
        tokio::select! {
            _ = ticker.tick() => {
                quote_count += 1;

                // Get Binance price
                let state = binance_state.read().await;
                let mut mid_price = state.mid;
                if mid_price <= 0.0 {
                    if quote_count > 50 { mid_price = 200.0; }
                    if quote_count % 100 == 0 {
                        warn!("[{}] Waiting for Binance price...", quote_count);
                    }
                    continue;
                }
                drop(state);

                // === PRICE GUARD: Store reference price for deviation check ===
                let price_at_calc = mid_price;

                // Update volatility
                vol_tracker.update(mid_price);
                let vol_mult = vol_tracker.spread_multiplier(
                    config.quant.volatility.min_spread_mult,
                    config.quant.volatility.max_spread_mult,
                    0.02,
                    0.10,
                );
                
                // === KRYPTON: Update LQ skewing volatility ===
                lq_skewing.update_volatility(vol_tracker.realized_vol());
                
                // === KRYPTON: Check fill quality and adjust spread ===
                fill_tracker.check_fills(mid_price);
                let fill_quality_mult = fill_tracker.spread_multiplier();
                let should_pause = fill_tracker.should_pause();
                if should_pause {
                    warn!("[KRYPTON] High adverse rate detected - pausing quotes");
                    continue;
                }

                // Get position from order manager
                let mgr = order_manager.read().await;
                let position = mgr.position();
                let realized_pnl = mgr.realized_pnl();
    let rebates = mgr.rebates();
                let rebates = mgr.rebates();
                let (fills, _vol_base, _vol_quote) = mgr.stats();
                drop(mgr);

                // === KRYPTON: LQ-Optimal Inventory Skewing ===
                let (reservation_price, skew_bps) = lq_skewing.calculate_reservation_price(
                    position,
                    mid_price,
                    Some(vol_tracker.realized_vol()),
                );
                // Trend detection: update with mid price and get asymmetric multipliers
                let trend_state = trend_detector.update(mid_price);
                let (bid_mult, ask_mult) = trend_detector.quote_multipliers();
                
                let (bid_skew, ask_skew): (f64, f64) = if config.quant.lq_skewing.enabled {
                    let (base_bid, base_ask) = lq_skewing.calculate_quote_skew(position, config.risk.max_position_base);
                    // Apply trend multipliers: downtrend -> widen bid; uptrend -> widen ask
                    (base_bid * bid_mult, base_ask * ask_mult)
                } else {
                    let (base_bid, base_ask) = inv_mgr.skew_bps(position);
                    (base_bid * bid_mult, base_ask * ask_mult)
                };

                // Calculate quote prices with fill quality adjustment
                let adjusted_spread_bps = config.strategy.base_spread_bps * vol_mult * fill_quality_mult;
                let base_spread = reservation_price * adjusted_spread_bps / 10000.0;
                let bid_price = reservation_price - base_spread - (reservation_price * bid_skew / 10000.0);
                let ask_price = reservation_price + base_spread + (reservation_price * ask_skew / 10000.0);

                // Round to tick
                let bid_price = (bid_price / config.market.price_tick).round() * config.market.price_tick;
                let ask_price = (ask_price / config.market.price_tick).round() * config.market.price_tick;

                let bid_moved = (bid_price - last_bid_price).abs() >= config.market.price_tick;
                let ask_moved = (ask_price - last_ask_price).abs() >= config.market.price_tick;

                // Check position limits
                let position_can_bid = position < config.risk.max_position_base;
                let position_can_ask = position > -config.risk.max_position_base;
                
                // In strong trends, pause quoting on the adverse side
                // Downtrend: don't bid (avoid buying into falling market)
                // Uptrend: don't ask (avoid selling into rising market)
                let trend_strength = trend_detector.strength();
                let strong_trend_threshold = 0.5;  // 50% trend strength
                
                let trend_skip_bid = trend_state == TrendState::Downtrend && trend_strength > strong_trend_threshold;
                let trend_skip_ask = trend_state == TrendState::Uptrend && trend_strength > strong_trend_threshold;
                
                let mut can_bid = position_can_bid && !trend_skip_bid;
                let mut can_ask = position_can_ask && !trend_skip_ask;
                
                // === MOMENTUM-BASED ENTRY ===
                if config.quant.momentum_entry.enabled {
                    let current_signal: i8 = if trend_state == TrendState::Uptrend { 1 }
                                             else if trend_state == TrendState::Downtrend { -1 }
                                             else { 0 };
                    
                    if current_signal != last_signal_direction {
                        signal_start_time = std::time::Instant::now();
                        last_signal_direction = current_signal;
                    }
                    
                    let signal_age_ms = signal_start_time.elapsed().as_millis() as u64;
                    let signal_stable = signal_age_ms >= config.quant.momentum_entry.signal_window_ms;
                    let fill_age_ms = last_fill_time.elapsed().as_millis() as u64;
                    let in_cooldown = fill_age_ms < config.quant.momentum_entry.cooldown_after_fill_ms;
                    let max_pos = config.quant.momentum_entry.max_position_before_exit * config.risk.max_position_base;
                    let exit_only = position.abs() >= max_pos;
                    
                    let mode_str = config.quant.momentum_entry.mode.as_str();
                    let (m_bid, m_ask) = if exit_only {
                        (position < 0.0, position > 0.0)
                    } else if in_cooldown || !signal_stable {
                        (position < 0.0, position > 0.0)
                    } else if mode_str == "one_sided" {
                        match current_signal {
                            1 => (true, position > 0.0),
                            -1 => (position < 0.0, true),
                            _ => (false, false),
                        }
                    } else {
                        (true, true)
                    };
                    
                    can_bid = can_bid && m_bid;
                    can_ask = can_ask && m_ask;
                    
                    if config.quant.momentum_entry.log_signals && current_signal != last_logged_signal {
                        match current_signal {
                            1 => info!("ğŸ“ˆ MOMENTUM: Bullish - BID ONLY"),
                            -1 => info!("ğŸ“‰ MOMENTUM: Bearish - ASK ONLY"),
                            _ => info!("â¸ï¸ MOMENTUM: Neutral"),
                        }
                        last_logged_signal = current_signal;
                    }
                }
                
                // Log when trend is causing quote pause
                if trend_skip_bid {
                    info!("[TREND] Strong downtrend ({:.0}%) - PAUSING BIDS", trend_strength * 100.0);
                }
                if trend_skip_ask {
                    info!("[TREND] Strong uptrend ({:.0}%) - PAUSING ASKS", trend_strength * 100.0);
                }

                // Log every 10s
                let log_interval = (10000 / config.strategy.refresh_interval_ms).max(1);
                if quote_count % log_interval == 0 {
                    let spread_bps = (ask_price - bid_price) / mid_price * 10000.0;
                    let ws_connected = matches!(*ws_state.read().await, 
                        crate::exchange::ConnectionState::Connected);
                    let ws_order_status = if let Some(ref client) = ws_order_client {
                        if client.read().await.is_connected() { "WS" } else { "REST-fb" }
                    } else { "REST" };
                    info!("[{}s] Mid:{:.4} | Pos:{:.4} | PnL:${:.4} | Reb:${:.4} | {} | {}",
                        quote_count * config.strategy.refresh_interval_ms / 1000,
                        mid_price, position, realized_pnl, rebates, fills,
                        ws_order_status);
                }

                // Update bid
                if bid_moved && can_bid {
                    // Cancel old order via REST (more reliable)
                    if let Some(ref old_id) = active_bid_id {
                        let _ = rest_client.cancel_order(old_id).await;
                    }

                    let base_size = config.strategy.order_size_quote / bid_price;
                    // === KRYPTON: Elastic sizing based on distance from fair ===
                    let size = if config.quant.elastic_sizing.enabled {
                        let inv_ratio = position / config.risk.max_position_base;
                        let (bid_sz, _) = elastic_sizer.calculate_bid_ask_sizes(
                            reservation_price, bid_price, ask_price, base_size, inv_ratio
                        );
                        bid_sz
                    } else {
                        base_size
                    };
                    let size = (size / config.market.size_step).floor() * config.market.size_step;

                    if size >= config.market.size_step {
                        // === PRE-TRADE CHECK: Verify price hasn't moved too much ===
                        if config.quant.stale_protection.enabled && config.quant.stale_protection.pre_trade_check {
                            let current_state = binance_state.read().await;
                            let current_mid = current_state.mid;
                            drop(current_state);
                            
                            let deviation_bps = ((current_mid - price_at_calc) / price_at_calc).abs() * 10000.0;
                            if deviation_bps > config.quant.stale_protection.max_deviation_bps {
                                // Price moved too much - skip this order to avoid adverse selection
                                if quote_count % 100 == 0 {
                                    warn!("[GUARD] Skipped bid: deviation {:.2}bps > {:.1}bps threshold",
                                        deviation_bps, config.quant.stale_protection.max_deviation_bps);
                                }
                                continue; // Skip to next tick
                            }
                        }

                        let client_oid = format!("bid_{}", quote_count);
                        
                        // Try WS first, fallback to REST
                        let order_result = if let Some(ref ws_client) = ws_order_client {
                            let client = ws_client.read().await;
                            if client.is_connected() {
                                let ws_req = WsOrderRequest {
                                    symbol: config.market.symbol.clone(),
                                    side: "buy".to_string(),
                                    price: format!("{:.4}", bid_price),
                                    size: format!("{:.2}", size),
                                    client_oid: client_oid.clone(),
                                    order_type: "limit".to_string(),
                                    time_in_force: Some("GTC".to_string()),
                                };
                                drop(client);
                                let client = ws_client.read().await;
                                match client.place_order(ws_req).await {
                                    Ok(resp) if resp.success => Ok(resp.order_id.unwrap_or(client_oid.clone())),
                                    Ok(resp) => Err(anyhow::anyhow!("WS order failed: {:?}", resp.msg)),
                                    Err(e) => Err(e),
                                }
                            } else {
                                drop(client);
                                // Fallback to REST
                                let order = OrderRequest {
                                    client_oid: client_oid.clone(),
                                    side: Side::Buy,
                                    symbol: config.market.symbol.clone(),
                                    order_type: OrderType::Limit,
                                    price: format!("{:.4}", bid_price),
                                    size: format!("{:.2}", size),
                                    time_in_force: Some(TimeInForce::GTC),
                                    post_only: Some(true),
                                    hidden: None,
                                    iceberg: None,
                                };
                                rest_client.place_order(&order).await
                            }
                        } else {
                            // REST only mode
                            let order = OrderRequest {
                                client_oid: client_oid.clone(),
                                side: Side::Buy,
                                symbol: config.market.symbol.clone(),
                                order_type: OrderType::Limit,
                                price: format!("{:.4}", bid_price),
                                size: format!("{:.2}", size),
                                time_in_force: Some(TimeInForce::GTC),
                                post_only: Some(true),
                                hidden: None,
                                iceberg: None,
                            };
                            rest_client.place_order(&order).await
                        };

                        match order_result {
                            Ok(order_id) => {
                                let mut mgr = order_manager.write().await;
                                mgr.register_order(
                                    order_id.clone(),
                                    client_oid,
                                    config.market.symbol.clone(),
                                    OrderSide::Buy,
                                    bid_price,
                                    size,
                                );
                                drop(mgr);

                                active_bid_id = Some(order_id);
                                last_bid_price = bid_price;
                                
                                // === KRYPTON: Record fill for quality tracking ===
                                // (This will be updated when we get the actual fill notification)
                            }
                            Err(e) => {
                                if quote_count % 50 == 0 {
                                    error!("Bid failed: {}", e);
                                }
                            }
                        }
                    }
                }

                // Update ask
                if ask_moved && can_ask {
                    if let Some(ref old_id) = active_ask_id {
                        let _ = rest_client.cancel_order(old_id).await;
                    }

                    let base_size = config.strategy.order_size_quote / ask_price;
                    // === KRYPTON: Elastic sizing based on distance from fair ===
                    let size = if config.quant.elastic_sizing.enabled {
                        let inv_ratio = position / config.risk.max_position_base;
                        let (_, ask_sz) = elastic_sizer.calculate_bid_ask_sizes(
                            reservation_price, bid_price, ask_price, base_size, inv_ratio
                        );
                        ask_sz
                    } else {
                        base_size
                    };
                    let size = (size / config.market.size_step).floor() * config.market.size_step;

                    if size >= config.market.size_step {
                        // === PRE-TRADE CHECK: Verify price hasn't moved too much ===
                        if config.quant.stale_protection.enabled && config.quant.stale_protection.pre_trade_check {
                            let current_state = binance_state.read().await;
                            let current_mid = current_state.mid;
                            drop(current_state);
                            
                            let deviation_bps = ((current_mid - price_at_calc) / price_at_calc).abs() * 10000.0;
                            if deviation_bps > config.quant.stale_protection.max_deviation_bps {
                                // Price moved too much - skip this order to avoid adverse selection
                                if quote_count % 100 == 0 {
                                    warn!("[GUARD] Skipped ask: deviation {:.2}bps > {:.1}bps threshold",
                                        deviation_bps, config.quant.stale_protection.max_deviation_bps);
                                }
                                continue; // Skip to next tick
                            }
                        }

                        let client_oid = format!("ask_{}", quote_count);
                        
                        // Try WS first, fallback to REST
                        let order_result = if let Some(ref ws_client) = ws_order_client {
                            let client = ws_client.read().await;
                            if client.is_connected() {
                                let ws_req = WsOrderRequest {
                                    symbol: config.market.symbol.clone(),
                                    side: "sell".to_string(),
                                    price: format!("{:.4}", ask_price),
                                    size: format!("{:.2}", size),
                                    client_oid: client_oid.clone(),
                                    order_type: "limit".to_string(),
                                    time_in_force: Some("GTC".to_string()),
                                };
                                drop(client);
                                let client = ws_client.read().await;
                                match client.place_order(ws_req).await {
                                    Ok(resp) if resp.success => Ok(resp.order_id.unwrap_or(client_oid.clone())),
                                    Ok(resp) => Err(anyhow::anyhow!("WS order failed: {:?}", resp.msg)),
                                    Err(e) => Err(e),
                                }
                            } else {
                                drop(client);
                                let order = OrderRequest {
                                    client_oid: client_oid.clone(),
                                    side: Side::Sell,
                                    symbol: config.market.symbol.clone(),
                                    order_type: OrderType::Limit,
                                    price: format!("{:.4}", ask_price),
                                    size: format!("{:.2}", size),
                                    time_in_force: Some(TimeInForce::GTC),
                                    post_only: Some(true),
                                    hidden: None,
                                    iceberg: None,
                                };
                                rest_client.place_order(&order).await
                            }
                        } else {
                            let order = OrderRequest {
                                client_oid: client_oid.clone(),
                                side: Side::Sell,
                                symbol: config.market.symbol.clone(),
                                order_type: OrderType::Limit,
                                price: format!("{:.4}", ask_price),
                                size: format!("{:.2}", size),
                                time_in_force: Some(TimeInForce::GTC),
                                post_only: Some(true),
                                hidden: None,
                                iceberg: None,
                            };
                            rest_client.place_order(&order).await
                        };

                        match order_result {
                            Ok(order_id) => {
                                let mut mgr = order_manager.write().await;
                                mgr.register_order(
                                    order_id.clone(),
                                    client_oid,
                                    config.market.symbol.clone(),
                                    OrderSide::Sell,
                                    ask_price,
                                    size,
                                );
                                drop(mgr);

                                active_ask_id = Some(order_id);
                                last_ask_price = ask_price;
                                
                                // === KRYPTON: Record fill for quality tracking ===
                                // (This will be updated when we get the actual fill notification)
                            }
                            Err(e) => {
                                if quote_count % 50 == 0 {
                                    error!("Ask failed: {}", e);
                                }
                            }
                        }
                    }
                }

                // Risk checks
                if realized_pnl <= -config.risk.max_loss_quote {
                    error!("ğŸ’€ STOP LOSS at ${:.2}", realized_pnl);
                    break;
                }
                if realized_pnl >= config.risk.max_profit_quote {
                    info!("ğŸ¯ TAKE PROFIT at ${:.2}", realized_pnl);
                    break;
                }
            }

            // Log WS order latency every 30s
            _ = latency_ticker.tick() => {
                if let Some(ref ws_client) = ws_order_client {
                    let client = ws_client.read().await;
                    client.log_latency().await;
                }
            }

            // Polling fallback
            _ = poll_ticker.tick() => {
                match rest_client.get_fills(&config.market.symbol, 10).await {
                    Ok(fills) => {
                        if !fills.is_empty() && fills.len() as u64 != last_poll_fills {
                            let mgr = order_manager.read().await;
                            let current_fills = mgr.stats().0;
                            drop(mgr);
                            
                            if current_fills < fills.len() as u64 {
                                warn!("[POLL] Detected {} fills via REST, WS has {}",
                                    fills.len(), current_fills);
                            }
                        }
                        last_poll_fills = fills.len() as u64;
                    }
                    Err(e) => {
                        warn!("[POLL] Failed to get fills: {}", e);
                    }
                }
            }
        }
    }

    // Shutdown
    info!("");
    info!("[SHUTDOWN] Cancelling all orders...");
    match rest_client.cancel_all_orders(&config.market.symbol).await {
        Ok(count) => info!("[SHUTDOWN] Cancelled {} orders", count),
        Err(e) => warn!("[SHUTDOWN] Cancel failed: {}", e),
    }

    // Log final WS latency stats
    if let Some(ref ws_client) = ws_order_client {
        let client = ws_client.read().await;
        client.log_latency().await;
    }

    let mgr = order_manager.read().await;
    let (fills, vol_base, vol_quote) = mgr.stats();
    let realized_pnl = mgr.realized_pnl();
    let rebates = mgr.rebates();
    drop(mgr);

    info!("");
    info!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    info!("                    SESSION SUMMARY                            ");
    info!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    info!("  Total Fills:    {}", fills);
    info!("  Volume (base):  {:.4}", vol_base);
    info!("  Volume (quote): ${:.2}", vol_quote);
    info!("  Realized PnL:   ${:.4}", realized_pnl);
    info!("  Rebates:        ${:.4}", rebates);
    info!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    Ok(())
}
